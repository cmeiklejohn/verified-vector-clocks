module 'vvclock' [ 'fresh'/0, 'increment'/2, 'equal@'/2, 'equal'/2, 'ble_nat'/2, 'descends@'/2, 'descends'/2, 'max@'/2, 'merge'/2, 'get_counter'/2, 'all_nodes'/1 ] attributes [ ] 

'fresh'/0 = fun() ->
  []
'increment'/2 = fun (_actor, _vclock) -> 
  case call 'Coq.Lists.List':'find'
            ( fun (_clock) -> 
                case _clock of
                  { 'Pair'
                  , _y
                  , _x
                  } when 'true' ->
                      call 'Coq.Arith.EqNat':'beq_nat'
                           ( _actor
                           , _y
                           )
                 end
            , _vclock
            ) of
    {'Some', _p} when 'true' ->
        case _p of
          { 'Pair'
          , _y
          , _x
          } when 'true' ->
              [{ 'Pair'
              , _y
              , {'S', _x}
              }|call 'Coq.Lists.List':'filter'
                   ( fun (_clock) -> 
                       case _clock of
                         { 'Pair'
                         , _y0
                         , _x0
                         } when 'true' ->
                             call 'Coq.Init.Datatypes':'negb' (call 'Coq.Arith.EqNat':'beq_nat'
                                    ( _actor
                                    , _y0
                                    ))
                        end
                   , _vclock
                   )]
         end
    'None' when 'true' ->
        [{ 'Pair'
        , _actor
        , {'S', 'O'}
        }|_vclock]
   end
'equal@'/2 = fun (_status_and_vclock, _clock) -> 
  case _clock of
    { 'Pair'
    , _count
    , _actor
    } when 'true' ->
        case _status_and_vclock of
          { 'Pair'
          , _vclock
          , _status
          } when 'true' ->
              case call 'Coq.Lists.List':'find'
                        ( fun (_clock0) -> 
                            case _clock0 of
                              { 'Pair'
                              , _y
                              , _x
                              } when 'true' ->
                                  call 'Coq.Arith.EqNat':'beq_nat'
                                       ( _count
                                       , _y
                                       )
                             end
                        , _status
                        ) of
                {'Some', _p} when 'true' ->
                    case _p of
                      { 'Pair'
                      , _y
                      , _n
                      } when 'true' ->
                          { 'Pair'
                          , case _vclock of
                            'True' when 'true' ->
                                call 'Coq.Arith.EqNat':'beq_nat'
                                     ( _actor
                                     , _n
                                     )
                            'False' when 'true' ->
                                'False'
                           end
                          , _status
                          }
                     end
                'None' when 'true' ->
                    { 'Pair'
                    , 'False'
                    , _status
                    }
               end
         end
   end
'equal'/2 = fun (_vc1, _vc2) -> 
  case call 'Coq.Lists.List':'fold_left'
            ( 'equal@'
            , _vc1
            , { 'Pair'
              , 'True'
              , _vc2
              }
            ) of
    { 'Pair'
    , _l
    , _b
    } when 'true' ->
        case _l of
          'True' when 'true' ->
              case call 'Coq.Lists.List':'fold_left'
                        ( 'equal@'
                        , _vc2
                        , { 'Pair'
                          , 'True'
                          , _vc1
                          }
                        ) of
                { 'Pair'
                , _l0
                , _b0
                } when 'true' ->
                    _l0
               end
          'False' when 'true' ->
              'False'
         end
   end
'ble_nat'/2 = fun (_n, _m) -> 
  case _n of
    'O' when 'true' ->
        'True'
    {'S', _n@} when 'true' ->
        case _m of
          'O' when 'true' ->
              'False'
          {'S', _m@} when 'true' ->
              call 'vvclock':'ble_nat'
                   ( _n@
                   , _m@
                   )
         end
   end
'descends@'/2 = fun (_status_and_vclock, _clock) -> 
  case _clock of
    { 'Pair'
    , _count
    , _actor
    } when 'true' ->
        case _status_and_vclock of
          { 'Pair'
          , _vclock
          , _status
          } when 'true' ->
              case call 'Coq.Lists.List':'find'
                        ( fun (_clock0) -> 
                            case _clock0 of
                              { 'Pair'
                              , _y
                              , _x
                              } when 'true' ->
                                  call 'Coq.Arith.EqNat':'beq_nat'
                                       ( _count
                                       , _y
                                       )
                             end
                        , _status
                        ) of
                {'Some', _p} when 'true' ->
                    case _p of
                      { 'Pair'
                      , _y
                      , _n
                      } when 'true' ->
                          { 'Pair'
                          , case _vclock of
                            'True' when 'true' ->
                                call 'vvclock':'ble_nat'
                                     ( _actor
                                     , _n
                                     )
                            'False' when 'true' ->
                                'False'
                           end
                          , _status
                          }
                     end
                'None' when 'true' ->
                    { 'Pair'
                    , 'False'
                    , _status
                    }
               end
         end
   end
'descends'/2 = fun (_vc1, _vc2) -> 
  case call 'Coq.Lists.List':'fold_left'
            ( 'descends@'/2
            , _vc2
            , { 'Pair'
              , 'True'
              , _vc1
              }
            ) of
    { 'Pair'
    , _l
    , _b
    } when 'true' ->
        _l
   end
'max@'/2 = fun (_vclock, _clock) -> 
  case _clock of
    { 'Pair'
    , _count
    , _actor
    } when 'true' ->
        case call 'Coq.Lists.List':'find'
                  ( fun (_clock0) -> 
                      case _clock0 of
                        { 'Pair'
                        , _y
                        , _x
                        } when 'true' ->
                            call 'Coq.Arith.EqNat':'beq_nat'
                                 ( _count
                                 , _y
                                 )
                       end
                  , _vclock
                  ) of
          {'Some', _p} when 'true' ->
              case _p of
                { 'Pair'
                , _y
                , _n
                } when 'true' ->
                    [{ 'Pair'
                    , _count
                    , call 'Coq.Init.Peano':'max'
                         ( _actor
                         , _n
                         )
                    }|call 'Coq.Lists.List':'filter'
                         ( fun (_clock0) -> 
                             case _clock0 of
                               { 'Pair'
                               , _y0
                               , _x
                               } when 'true' ->
                                   call 'Coq.Init.Datatypes':'negb' (call 'Coq.Arith.EqNat':'beq_nat'
                                          ( _count
                                          , _y0
                                          ))
                              end
                         , _vclock
                         )]
               end
          'None' when 'true' ->
              [{ 'Pair'
              , _count
              , _actor
              }|_vclock]
         end
   end
'merge'/2 = fun (_vc1, _vc2) -> 
  call 'Coq.Lists.List':'fold_left'
       ( 'max@'/2
       , _vc1
       , _vc2
       )
'get_counter'/2 = fun (_actor, _vclock) -> 
  case call 'Coq.Lists.List':'find'
            ( fun (_clock) -> 
                case _clock of
                  { 'Pair'
                  , _y
                  , _x
                  } when 'true' ->
                      call 'Coq.Arith.EqNat':'beq_nat'
                           ( _actor
                           , _y
                           )
                 end
            , _vclock
            ) of
    {'Some', _p} when 'true' ->
        case _p of
          { 'Pair'
          , _vc
          , _a
          } when 'true' ->
              {'Some', _a}
         end
    'None' when 'true' ->
        'None'
   end
'all_nodes'/1 = fun (_vclock) -> 
  case _vclock of
    [] when 'true' ->
        []
    [_cs|_c] when 'true' ->
        case _cs of
          { 'Pair'
          , _y
          , _x
          } when 'true' ->
              [_y|call 'vvclock.VVClock':'all_nodes' (_c)]
         end
   end
end
